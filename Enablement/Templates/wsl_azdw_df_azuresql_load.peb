{# -- TemplateVersion:002 MinVersion:8210 MaxVersion:* TargetType:AzureDW Objects:* TemplateType:Powershell32                                               -- #}
{#                                                                                                                                                          -- #}
{# --    (c) WhereScape Inc 2020. WhereScape Inc permits you to copy this Template solely for use with the RED software, and to modify this Template        -- #}
{# --    for the purposes of using that modified Template with the RED software, but does not permit copying or modification for any other purpose.         -- #}
{# --                                                                                                                                                       -- #}
{# -- =============================================================================                                                                         -- #}
{# --                                                                                                                                                       -- #}
{# -- DBMS Name          : Azure SQL Data Warehouse                                                                                                         -- #}
{# -- Template Name      : wsl_azdw_df_azuresql_load                                                                                                        -- #}
{# -- Template Version   : 8.2.1.0                                                                                                                          -- #}
{# -- Description        : This template creates an Azure Powershell script specifically                                                                    -- #}
{# --                      designed for loads from Azure SQL Database                                                                                       -- #}
{# --                                                                                                                                                       -- #}
{# -- =============================================================================                                                                         -- #}
{# --                                                                                                                                                       -- #}
{# --                                                                                                                                                       -- #}
{# -- Notes / History                                                                                                                                       -- #}
{# --                                                                                                                                                       -- #}
{# --                                                                                                                                                       -- #}
#=============================================================================={%- br %}
# DBMS Name        :    {{table.dbType.name}}{%- br %}
# Template Version :    8.0.1.0{%- br %}
# Description      :    Load {{table.name}}{%- br %}
# Generated by     :    {{env.productVersion}}{%- br %}
# Generated for    :    {{env.licensedTo}}{%- br %}
# Generated on     :    {{env.currentTimestamp}}{%- br %}
# Author           :    {{env.userName}}{%- br %}
#=============================================================================={%- br %}
Import-Module WslPowershellCommon -DisableNameChecking

Hide-Window
$null = [System.Reflection.Assembly]::LoadFile($(Join-Path -Path ${env:WSL_BINDIR} -ChildPath "Newtonsoft.Json.dll"))

function Print-Log { {%- br %}
    try { {%- br %}
        $logStream.Dispose(){%- br %}
        $logReader = New-Object IO.StreamReader($fileAud){%- br %}
        while( ! $logReader.EndOfStream) { {%- br %}
            [Console]::WriteLine($logReader.ReadLine())
        } {%- br %}
        $logReader.Dispose()
    }{%- br %}
    catch { {%- br %}
        [Console]::WriteLine($_.Exception.Message)
        [Console]::WriteLine("Failed to print log file")
    }{%- br %}
} {%- br %}

function Get-ExtendedProperty { 
    param(
        $propertyName,
        $tableName
    )
    Add-Type -Path $(Join-Path -Path ${env:WSL_BINDIR} -ChildPath 'WslMetadataServiceClient.dll')
    $metaDbType = [WslMetadataServiceClient.MetaDatabaseType]::SqlServer
    # Metadata DSN, Meta DB Type enum, Metadata User, Metadata Password, Metadata schema
    $repo = New-Object WslMetadataServiceClient.Repo(${env:WSL_META_DSN},$metaDbType,${env:WSL_META_USER},${env:WSL_META_PWD},"dbo.")
    $root = $repo.objectsByName
    $value = $root[${tableName}].extendedPropertyValuesByName[$propertyName].GetValue()
    if([string]::IsNullOrEmpty($value)) { 
        $value = $root[${tableName}].loadInfo.sourceConnection.extendedPropertyValuesByName[$propertyName].GetValue()
    }
    if([string]::IsNullOrEmpty($value)) { 
        $value = $root[${tableName}].target.connection.extendedPropertyValuesByName[$propertyName].GetValue()
    }
    $repo.Dispose()
    return , $value
}

$dataFactoryName = "WSL-$(${env:WSL_LOAD_TABLE}.Replace('_',''))-${env:WSL_SEQUENCE}-$([GUID]::NewGuid().Guid)"

# Get Extended Property Values
{# Server=tcp:<server>,<port>;Database=<database>;User ID=$USERNAME$;Password=$PASSWORD$;Trusted_Connection=False;Encrypt=True;Connection Timeout=30 #}
{# $USERNAME$ and $PASSWORD$ are tokens which are replaced at script runtime #}
$azureSqlConnectionString = Get-ExtendedProperty -PropertyName "AZ_DF_SRC_CONN_STR" -TableName ${env:WSL_LOAD_TABLE}
$azureDwConnectionString = Get-ExtendedProperty -PropertyName "AZ_DF_TGT_CONN_STR" -TableName ${env:WSL_LOAD_TABLE}

$azureSqlConnectionString = $azureSqlConnectionString.Replace('$USERNAME$',${env:WSL_SRC_USER}).Replace('$PASSWORD$',${env:WSL_SRC_PWD})
$azureDwConnectionString = $azureDwConnectionString.Replace('$USERNAME$',${env:WSL_TGT_USER}).Replace('$PASSWORD$',${env:WSL_TGT_PWD})

$azureStorageAccount = Get-ExtendedProperty -PropertyName "BLOB_ACCOUNT" -TableName ${env:WSL_LOAD_TABLE}
$azureStorageAccountKey = Get-ExtendedProperty -PropertyName "BLOB_KEY" -TableName ${env:WSL_LOAD_TABLE}
$azureAccountName = Get-ExtendedProperty -PropertyName "AZ_RM_LOGIN" -TableName ${env:WSL_LOAD_TABLE}
$azurePassword = Get-ExtendedProperty -PropertyName "AZ_RM_PWD" -TableName ${env:WSL_LOAD_TABLE}
$azureSubscriptionId = Get-ExtendedProperty -PropertyName "AZ_SUBSCRIPTION_ID" -TableName ${env:WSL_LOAD_TABLE}
$azureTenantId = Get-ExtendedProperty -PropertyName "AZ_TENANT_ID" -TableName ${env:WSL_LOAD_TABLE}
$azureDataFactoryLocation = Get-ExtendedProperty -PropertyName "AZ_DF_LOCATION" -TableName ${env:WSL_LOAD_TABLE}
$azureResourceGroupName = Get-ExtendedProperty -PropertyName "AZ_DF_RG" -TableName ${env:WSL_LOAD_TABLE}

$fileAud = Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "wsl_${env:WSL_LOAD_TABLE}_${env:WSL_SEQUENCE}.aud"

try {
    Import-Module AzureRM.DataFactoryV2
}
catch {
    Write-Output -2
    Write-Output "Module AzureRM.DataFactoryV2 is not installed"
    exit
}


$azurePassword = ConvertTo-SecureString $azurePassword -AsPlainText -Force
$psCred = New-Object System.Management.Automation.PSCredential($azureAccountName, $azurePassword)

# Login to Azure
if( ( ! [string]::IsNullOrWhiteSpace($azureSubscriptionId)) -and ( ! [string]::IsNullOrWhiteSpace($azureTenantId))) {
    $null = Connect-AzureRmAccount -Credential $psCred -Subscription $azureSubscriptionId -TenantId $azureTenantId
}
elseif( ! [string]::IsNullOrWhiteSpace($azureSubscriptionId)) {
    $null = Connect-AzureRmAccount -Credential $psCred -Subscription $azureSubscriptionId
}
elseif( ! [string]::IsNullOrWhiteSpace($azureTenantId)) {
    $null = Connect-AzureRmAccount -Credential $psCred -TenantId $azureTenantId
}
else {
    $null = Connect-AzureRmAccount -Credential $psCred
}

$logStream = New-Object System.IO.StreamWriter($fileAud,$false)
$logStream.AutoFlush = $true

$azureSqlDatabaseLinkedService = "AzureSqlDatabaseLinkedService${env:WSL_SEQUENCE}"
$azureSqlDataWarehouseLinkedService = "AzureSqlDataWarehouseLinkedService${env:WSL_SEQUENCE}"
$azureStorageLinkedService = "AzureStorageLinkedService${env:WSL_SEQUENCE}"
$azureSqlDatabaseDataset = "AzureSqlDatabaseDataset${env:WSL_SEQUENCE}"
$azureSqlDataWarehouseDataset = "AzureSqlDataWarehouseDataset${env:WSL_SEQUENCE}"
$CopyDataPipeline = "CopyData${env:WSL_SEQUENCE}"

$ErrorActionPreference = "Stop"

try {

    # create a data factory
    $df = Set-AzureRmDataFactoryV2 -ResourceGroupName $azureResourceGroupName -Location $azureDataFactoryLocation -Name $dataFactoryName

    # Define a linked service for Azure SQL Database
    $azureSQLDatabaseLinkedServiceDefinition = @"
{
    "name": "$azureSqlDatabaseLinkedService",
    "properties": {
        "type": "AzureSqlDatabase",
        "typeProperties": {
            "connectionString": {
                "type": "SecureString",
                "value": "$azureSqlConnectionString"
            }
        }
    }
}
"@
    $sdlsJson = $(Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "$azureSqlDatabaseLinkedService.json")

    # Store the JSON definition in a file that will be used by the Set-AzureRmDataFactoryV2LinkedService command. 
    $azureSQLDatabaseLinkedServiceDefinition | Out-File $sdlsJson

    # Creates an Azure Storage linked service
    $dblsRes = Set-AzureRmDataFactoryV2LinkedService -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -Name $azureSqlDatabaseLinkedService -File $sdlsJson
    if(${env:DEBUG} -eq "TRUE") {
        $logStream.WriteLine(($dblsRes | Out-String).Trim())
    }


    # Define a linked service for Azure SQL Datawarehouse (sink)
    $azureSQLDataWarehouseLinkedServiceDefinition = @"
{
    "name": "$azureSqlDataWarehouseLinkedService",
    "properties": {
        "type": "AzureSqlDW",
        "typeProperties": {
            "connectionString": {
                "type": "SecureString",
                "value": "$azureDwConnectionString"
            }
        }
    }
}
"@

    $dwlsJson = $(Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "$azureSqlDataWarehouseLinkedService.json")

    # Store the JSON definition in a file that will be used by the Set-AzureRmDataFactoryV2LinkedService command. 
    $azureSQLDataWarehouseLinkedServiceDefinition | Out-File $dwlsJson

    # Create a linked service for Azure SQL Datawarehouse (sink)
    $dwlsRes = Set-AzureRmDataFactoryV2LinkedService -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -Name $azureSqlDataWarehouseLinkedService -File $dwlsJson
    if(${env:DEBUG} -eq "TRUE") {
        $logStream.WriteLine(($dwlsRes | Out-String).Trim())
    }

    # Define an linked service for Azure Storage Account. Interim storage to enable PolyBase
    $storageLinkedServiceDefinition = @"
{
    "name": "$azureStorageLinkedService",
    "properties": {
        "type": "AzureStorage",
        "typeProperties": {
            "connectionString": {
                "value": "DefaultEndpointsProtocol=https;AccountName=$azureStorageAccount;AccountKey=$azureStorageAccountKey",
                "type": "SecureString"
            }
        }
    }
}
"@
    $slsJson = $(Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "$azureStorageLinkedService.json")

    # Store the JSON definition in a file that will be used by the Set-AzureRmDataFactoryV2LinkedService command. 
    $storageLinkedServiceDefinition | Out-File $slsJson

    # Creates an Azure Storage linked service
    $slsRes = Set-AzureRmDataFactoryV2LinkedService -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -Name $azureStorageLinkedService -File $slsJson
    if(${env:DEBUG} -eq "TRUE") {
        $logStream.WriteLine(($slsRes | Out-String).Trim())
    }

    # Define the input dataset (Azure SQL Database)
    $azureSqlDatabaseDatasetDefiniton = @"
{
    "name": "$azureSqlDatabaseDataset",
    "properties": {
        "type": "AzureSqlTable",
        "linkedServiceName": {
            "referenceName": "$azureSqlDatabaseLinkedService",
            "type": "LinkedServiceReference"
        },
        "typeProperties": {
            "tableName": "dummy"
        }
    }
}
"@

    $sddJson = $(Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "$azureSqlDatabaseDataset.json")

    # Store the JSON definition in a file that will be used by the Set-AzureRmDataFactoryV2Dataset command. 
    $azureSqlDatabaseDatasetDefiniton | Out-File $sddJson

    # Create a dataset in the data factory
    $sddRes = Set-AzureRmDataFactoryV2Dataset -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -Name $azureSqlDatabaseDataset -File $sddJson
    if(${env:DEBUG} -eq "TRUE") {
        $logStream.WriteLine(($sddRes | Out-String).Trim())
    }


    # Define the output dataset (Azure SQL Data Warehouse)
    $azureSqlDataWarehouseDatasetDefiniton = @"
{
    "name": "$azureSqlDataWarehouseDataset",
    "properties": {
        "type": "AzureSqlDWTable",
        "linkedServiceName": {
            "referenceName": "$azureSqlDataWarehouseLinkedService",
            "type": "LinkedServiceReference"
        },
        "typeProperties": {
            "tableName": {
                "value": "@{dataset().DWTableName}",
                "type": "Expression"
            }
        },
        "parameters":{
            "DWTableName":{
                "type":"String"
            }
        }
    }
}
"@

    $dwdJson = $(Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "$azureSqlDataWarehouseDataset.json")

    # Store the JSON definition in a file that will be used by the Set-AzureRmDataFactoryV2Dataset command. 
    $azureSqlDataWarehouseDatasetDefiniton | Out-File $dwdJson

    # Create a dataset in the data factory
    $dwdRes = Set-AzureRmDataFactoryV2Dataset -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -Name $azureSqlDataWarehouseDataset -File $dwdJson
    if(${env:DEBUG} -eq "TRUE") {
        $logStream.WriteLine(($dwdRes | Out-String).Trim())
    }

    # Define a pipeline in the data factory that copies data from source SQL Database to sink SQL Data Warehouse
    $pipelineDefinition = @"
{
    "name": "$CopyDataPipeline",
    "properties": {
        "activities": [
            {
                "name": "CopyData",
                "description": "Copy data from SQL database to SQL DW",
                "type": "Copy",
                "inputs": [
                    {
                        "referenceName": "$azureSqlDatabaseDataset",
                        "type": "DatasetReference"
                    }
                ],
                "outputs": [
                    {
                        "referenceName": "$azureSqlDataWarehouseDataset",
                        "type": "DatasetReference",
                        "parameters": {
                            "DWTableName": "${env:WSL_LOAD_FULLNAME}"
                        }
                    }
                ],
                "typeProperties": {
                    "source": {
                        "type": "SqlSource",
                        "sqlReaderQuery": "SELECT
      {%- from table.columns as column %}
        {%- if not loop.first %}                                                , {% else %} {% endif %}
        {%- if column.transformType.code != "A" %}
          {{- column.source.replace(codepoint(34),codepoint(92)+codepoint(34)) }}
        {%- else %}
          {%- if column.sourceTable is defined and column.sourceColumn is defined %}
            {%- fetch column.sourceTable %}
            {{- column.sourceTable.name.replace(codepoint(34),codepoint(92)+codepoint(34)) }}.
          {%- endif %}
          {%- if column.sourceColumn is defined %}
              {{- column.sourceColumn.name.replace(codepoint(34),codepoint(92)+codepoint(34)) }}
          {%- else %}NULL
          {%- endif %}
        {%- endif %}
        {%- br %}
      {%- endfrom %}
                                           FROM $(${env:WSL_SRC_SCHEMA}.Replace('"','\"')).{{ table.loadInfo.sourceTables.replace(codepoint(34),codepoint(92)+codepoint(34)) }} {{table.loadInfo.sourceTables.replace(codepoint(34),codepoint(92)+codepoint(34)) }}
    {%- from table.loadInfo.whereAndGroupByClauses | lines as whereLine %}
{%- br %}                                           {{ whereLine.replace(codepoint(34),codepoint(92)+codepoint(34)) -}}
    {%- endfrom %}"{% br %}
                    },
                    "sink": {
                        "type": "SqlDWSink",
                        "allowPolyBase": true
                    },
                    "enableStaging": true,
                    "stagingSettings": {
                        "linkedServiceName": {
                            "referenceName": "$azureStorageLinkedService",
                            "type": "LinkedServiceReference"
                        }
                    }
                }
            }
        ]
    }
}
"@

    $extractSql = ($pipelineDefinition | ConvertFrom-Json).properties.activities.typeProperties.source.sqlReaderQuery
    $logStream.WriteLine("Extract SQL:")
    $logStream.WriteLine($extractSql.Replace("                                           ",""))
    $logStream.WriteLine("")
    
    $pdJson = $(Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "$CopyDataPipeline.json")

    # Store the JSON definition in a file that will be used by the Set-AzureRmDataFactoryV2Pipeline command. 
    $pipelineDefinition | Out-File $pdJson

    # Create a pipeline in the data factory
    $pdRes = Set-AzureRmDataFactoryV2Pipeline -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -Name $CopyDataPipeline -File $pdJson
    if(${env:DEBUG} -eq "TRUE") {
        $logStream.WriteLine(( $pdRes | Out-String ))
    }
    
    # Create a pipeline run
    $runId = Invoke-AzureRmDataFactoryV2Pipeline -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -PipelineName $CopyDataPipeline

    # Check the pipeline run status until it finishes the copy operation
    Start-Sleep -Seconds 10
    while ($True) {
        $result = Get-AzureRmDataFactoryV2ActivityRun -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -PipelineRunId $runId -RunStartedAfter (Get-Date).AddMinutes(-30) -RunStartedBefore (Get-Date).AddMinutes(30)

        if (($result | Where-Object { $_.Status -eq "InProgress" } | Measure-Object).count -ne 0) {
            Start-Sleep -Seconds 10
        }
        else {
            break
        }
    }

    # Get the activity run details 
    $result = Get-AzureRmDataFactoryV2ActivityRun -DataFactoryName $dataFactoryName -ResourceGroupName $azureResourceGroupName -PipelineRunId $runId -RunStartedAfter (Get-Date).AddMinutes(-10)      -RunStartedBefore (Get-Date).AddMinutes(10)
    $allSuccess = $true
    foreach($res in $result) {
        if($res.Status -ne "Succeeded") {
            $allSuccess = $false
        }
    }

    if ($allSuccess) {
        $logStream.WriteLine("Rows read: " + $result[0].Output.SelectToken("rowsRead").Value.ToString())
        $logStream.WriteLine("Rows loaded: " + $result[0].Output.SelectToken("rowsCopied").Value.ToString())
        $logStream.WriteLine("")
        $logStream.WriteLine("Data read: " + [math]::Round($($result[0].Output.SelectToken("dataRead").Value/1024/1024),2).ToString() + " MiB")
        $logStream.WriteLine("Data written: " + [math]::Round($($result[0].Output.SelectToken("dataWritten").Value/1024/1024),2).ToString() + " MiB")
        $logStream.WriteLine("Copy duration: " + $result[0].Output.SelectToken("copyDuration").Value.ToString() + " sec")
    }
    else {
        foreach($line in $result.Error) {
            $logStream.WriteLine($line)
        }
    }

    Write-Output 1
    Write-Output "Pipeline complete"
}
catch {

    Write-Output -2
    Write-Output "Pipeline failed"

    $logStream.WriteLine($_.Exception.Message)
    $logStream.WriteLine($_.InvocationInfo.PositionMessage)
}
finally {

    Print-Log

    try {$null = Remove-AzureRmDataFactoryV2 -Name $dataFactoryName -ResourceGroupName $azureResourceGroupName -Force } catch {}
    
    if(${env:DEBUG} -ne "TRUE") {
    
        try {$null = Remove-Item $sdlsJson } catch {}
        try {$null = Remove-Item $dwlsJson } catch {}
        try {$null = Remove-Item $slsJson } catch {}
        try {$null = Remove-Item $sddJson } catch {}
        try {$null = Remove-Item $dwdJson } catch {}
        try {$null = Remove-Item $pdJson } catch {}
        try {$null = Remove-Item $p2dJson } catch {}
        try {$null = Remove-Item $fileAud } catch {}
        
    }
}
