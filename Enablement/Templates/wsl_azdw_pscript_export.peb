{# -- TemplateVersion:002 MinVersion:8010 MaxVersion:* TargetType:AzureDW Objects:* TemplateType:Powershell64                                               -- #}
{#                                                                                                                                                          -- #}
{# --    (c) WhereScape Inc 2020. WhereScape Inc permits you to copy this Template solely for use with the RED software, and to modify this Template        -- #}
{# --    for the purposes of using that modified Template with the RED software, but does not permit copying or modification for any other purpose.         -- #}
{# --                                                                                                                                                       -- #}
{# -- =============================================================================                                                                         -- #}
{# --                                                                                                                                                       -- #}
{# -- DBMS Name          : Azure SQL Data Warehouse                                                                                                         -- #}
{# -- Template Name      : wsl_azdw_pscript_export                                                                                                          -- #}
{# -- Template Version   : 8.0.1.0                                                                                                                          -- #}
{# -- Description        : This template creates an Azure Powershell script                                                                                 -- #}
{# --                      specifically designed for all RED exports                                                                                        -- #}
{# --                                                                                                                                                       -- #}
{# -- =============================================================================                                                                         -- #}
{# --                                                                                                                                                       -- #}
{# --                                                                                                                                                       -- #}
{# -- Notes / History                                                                                                                                       -- #}
{# -- TK: Azure SQL DW Release 1.0.0 (2017-08-03)                                                                                                           -- #}
{# -- PX: Amended for 64-bit support (2019-10-04)                                                                                                           -- #}
{# --                                                                                                                                                       -- #}
#=============================================================================={%- br %}
# DBMS Name        :    {{table.dbType.name}}{%- br %}
# Template Version :    8.4.1.0{%- br %}
# Description      :    Export {{table.name}}{%- br %}
# Generated by     :    {{env.productVersion}}{%- br %}
# Generated for    :    {{env.licensedTo}}{%- br %}
# Generated on     :    {{env.currentTimestamp}}{%- br %}
# Author           :    {{env.userName}}{%- br %}
#=============================================================================={%- br %}
# Notes / History{%- br %}
#{%- br %}
$t        = '[DllImport("user32.dll")] public static extern bool ShowWindow(int handle, int state);'{%- br %}
add-type -name win -member $t -namespace native{%- br %}
$parent   = (Get-WmiObject Win32_Process | select ProcessID, ParentProcessID | where { $_.ProcessID -eq ([System.Diagnostics.Process]::GetCurrentProcess()).id }).ParentProcessID{%- br %}
$currwind = ([System.Diagnostics.Process]::GetProcessById($parent) | Get-Process).MainWindowHandle{%- br %}
$null     = [native.win]::ShowWindow($currwind, 0){%- br %}
{%- br %}
function Print-Log { {%- br %}
    try { {%- br %}
        $logStream.Dispose(){%- br %}
        $logReader = New-Object IO.StreamReader($fileAud){%- br %}
        while( ! $logReader.EndOfStream) { {%- br %}
            [Console]::WriteLine($logReader.ReadLine())
        } {%- br %}
        $logReader.Dispose()
    }{%- br %}
    catch { {%- br %}
        [Console]::WriteLine($_.Exception.Message)
        [Console]::WriteLine("Failed to print log file")
    }{%- br %}
} {%- br %}
{%- br %}
# Define ODBC Read function{%- br %}
function Get-ODBC-Data{ {%- br %}
    param({%- br %}
        [string]$query    = "",{%- br %}
        [string]$dsn      = "",{%- br %}
        [string]$username = "",{%- br %}
        [string]$password = "",{%- br %}
        [switch]$outFile{%- br %}
    ){%- br %}
    $odbcConn                  = New-Object Data.Odbc.OdbcConnection{%- br %}
    $odbcConn.ConnectionString = "DSN=$dsn"{%- br %}
    if(![string]::IsNullOrEmpty($username)){ {%- br %}
        $odbcConn.ConnectionString += ";UID=$username"{%- br %}
    }{%- br %}
    if(![string]::IsNullOrEmpty($password)){ {%- br %}
        $odbcConn.ConnectionString += ";PWD=$password"{%- br %}
    }{%- br %}
    try { {%- br %}
        $odbcConn.open(){%- br %}
        $odbcCommand = New-object Data.Odbc.OdbcCommand($query,$odbcConn){%- br %}
        if($outFile) { {%- br %}
            $format               = New-Object Text.UTF8Encoding
            $odbcReader           = $odbcCommand.ExecuteReader(){%- br %}
            $columnCount          = $odbcReader.FieldCount{%- br %}
            $sb                   = New-Object Text.StringBuilder{%- br %}
            $fileStream           = New-Object IO.StreamWriter($fileDat,$false,$Format){%- br %}
            $fileStream.AutoFlush = $true{%- br %}
            $rowCount             = 0{%- br %}
            while($odbcReader.Read()) { {%- br %}
                [System.Collections.ArrayList]$data = @(){%- br %}
                for($x = 0; $x -lt $columnCount; $x++){ {%- br %}
                    if($odbcReader.IsDBNull($x)) { {%- br %}
                        [void]$data.Add(""){%- br %}
                    } {%- br %}
                    else { {%- br %}
                        [void]$data.Add($odbcReader.GetValue($x).ToString().Replace([regex]::Escape($fileDelim),'&delim;')){%- br %}
                    }{%- br %}
                }{%- br %}
                [void]$sb.clear(){%- br %}
                $row  = $data.ToArray(){%- br %}
                $work = [string]::Join($fileDelim,$row){%- br %}
                $work = $work.Replace("`n","&LF;"){%- br %}
                $work = $work.Replace("`r","&CR;"){%- br %}
                [void]$sb.Append($work){%- br %}
                if($rowCount -gt 0) { {%- br %}
                    $fileStream.Write("`r`n")
                }{%- br %}
                $fileStream.Write($sb.ToString()){%- br %}
                $rowCount++{%- br %}
            }{%- br %}
            $fileStream.Dispose(){%- br %}
            $odbcConn.Dispose(){%- br %}
            return $rowCount, $fileDat{%- br %}
        }{%- br %}
        else { {%- br %}
            $dataTable = New-Object Data.DataTable{%- br %}
            $null      = (New-Object Data.odbc.odbcDataAdapter($odbcCommand)).fill($dataTable){%- br %}
            $odbcConn.Dispose(){%- br %}
            return $dataTable.Rows.Count, $dataTable, $dataTable.Columns{%- br %}
        }{%- br %}
    } {%- br %}
    catch { {%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("Export failed"){%- br %}
        $logStream.WriteLine($error[0].Exception.Message){%- br %}
        $logStream.WriteLine($error[0].InvocationInfo.PositionMessage){%- br %}
        Print-Log{%- br %}
        exit{%- br %}
    }{%- br %}
}{%- br %}
{%- br %}
Function Replace-WslTags($stuff) { {%- br %}
    if([string]::IsNullOrWhitespace($stuff)) { {%- br %}
        return $stuff{%- br %}
    }{%- br %}
    if($stuff.Contains('$SEQUENCE$')) { {%- br %}
        $stuff = $stuff.Replace('$SEQUENCE$',${env:WSL_SEQUENCE}){%- br %}
    }{%- br %}
    if([regex]::IsMatch($stuff,'\$.+\$')) { {%- br %}
        # If $stuff contains two or more $s and the $SEQUENCE$ string is not detected{%- br %}
        # or has already been replaced then we assume a date{%- br %}
        while([regex]::IsMatch($stuff,'\$.+\$')) { {%- br %}
            $startPos       = $stuff.IndexOf('$'){%- br %}
            $work           = $stuff.SubString($startPos + 1){%- br %}
            $endPos         = $work.IndexOf('$'){%- br %}
            $suppliedFormat = $work.SubString(0, $endPos){%- br %}
            $dateFormat     = $suppliedFormat.Replace('YY','yy').Replace('DD','dd').Replace('HH','hh').Replace('MI','mm').Replace('SS','ss'){%- br %}
            $dateString     = (Get-Date -f $dateFormat){%- br %}
            $replaceString  = '$' + $suppliedFormat + '$'{%- br %}
            $stuff          = $stuff.Replace($replaceString,$dateString){%- br %}
        }{%- br %}
    }{%- br %}
    if($stuff.Contains('$')) { {%- br %}
        ${env:warn} = $true{%- br %}
        $logStream.WriteLine("Unclosed '$' tag in '$stuff'"){%- br %}
        $logStream.WriteLine("Unclosed '$' will be removed"){%- br %}
        $stuff      = $stuff.Replace('$',''){%- br %}
    }{%- br %}
    return $stuff.Trim(){%- br %}
}{%- br %}

# Gzip function{%- br %}
function Gzip-File { {%- br %}
    param({%- br %}
        [string]$inFile = $(throw "No input file specified"),{%- br %}
        [string]$outFile = $inFile + ".gz",{%- br %}
        [switch]$removeOriginal = $false{%- br %}
    ){%- br %}
    {%- br %}
    $input = New-Object IO.FileStream $InFile, ([IO.FileMode]::Open), ([IO.FileAccess]::Read), ([IO.FileShare]::Read){%- br %}
    $output = New-Object IO.FileStream $OutFile, ([IO.FileMode]::Create), ([IO.FileAccess]::Write), ([IO.FileShare]::None){%- br %}
    $gzipStream = New-Object IO.Compression.GzipStream $Output, ([IO.Compression.CompressionLevel]::Fastest){%- br %}
    {%- br %}
    $input.CopyTo($gzipStream){%- br %}
    {%- br %}
    $gzipStream.Dispose(){%- br %}
    $output.Dispose(){%- br %}
    $input.Dispose(){%- br %}
    {%- br %}
    if($removeOriginal) { {%- br %}
        Remove-Item -Path $inFile{%- br %}
    }{%- br %}
    {%- br %}
    return (gci $outFile).Name{%- br %}
}{%- br %}

{%  if (table.exportInfo.compressAfterExport  == true)  %}
function Archive-Files {
    param({%- br %}
        [string]$srcFile = $(throw "No input file specified"){%- br %}
    ){%- br %}
    try { {%- br %}
        $utilityPath = "{{table.exportInfo.compressUtility.path}}"{%- br %}
        $utilityName = '{{table.exportInfo.compressUtility.name}}'{%- br %}
        $utilityParameters='{{table.exportInfo.compressParameters}}'{%- br %}
        $utilityParameters = $utilityParameters.Replace('$EXPFILE$',$srcFile){%- br %}

        {% if (table.exportInfo.compressUtility.path == "") %}{%- br %}
        $outPath = $srcFile.Split('.')[0]
        $outPath = $outPath + '.gz'
        $gzipResult = Gzip-File -inFile $srcFile -outFile $outPath -removeOriginal $true {%- br %}
        $logStream.WriteLine($gzipResult){%- br %}
        $logStream.WriteLine("File Compressed using Gzip"){%- br %}
        {%  elseif (table.exportInfo.compressUtility.path != "")  %}{%- br %}
        $isUtilityPath = Test-Path $utilityPath
        if ($isUtilityPath -eq "True"){ {%- br %}
            $utilityPath = Join-Path -Path $utilityPath -ChildPath $utilityName {%- br %}
            $compressFileCMD = '& "{{table.exportInfo.compressUtility.path}}\{{table.exportInfo.compressUtility.name}}" ' + $utilityParameters
            $compressFile = Invoke-Expression $compressFileCMD
            $logStream.WriteLine("$compressFile"){%- br %}
            $logStream.WriteLine('File Compressed using command: ' + $compressFileCMD){%- br %}
            $removeFile = Remove-Item $srcFile {%- br %}
    } {%- br %}
        {%- endif %}
    }catch { {%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("File Archive Failed"){%- br %}
        $logStream.WriteLine($_.Exception.Message){%- br %}
        $logStream.WriteLine($_.InvocationInfo.PositionMessage){%- br %}
        Print-Log{%- br %}
        exit{%- br %}
    }{%- br %}
}
{%- endif %}

# Get Extended Properties{%- br %}
function Get-ExtendedProperty { {%- br %}
    param({%- br %}
        $propertyName{%- br %}
    ){%- br %}
    $metaArch = if (${env:WSL_META_DSN_ARCH} -eq "64") {[WslMetadataServiceClient.Architecture]::_64bit} else {[WslMetadataServiceClient.Architecture]::_32bit}
    $repo     = New-Object WslMetadataServiceClient.Repo(${env:WSL_META_DSN},$metaDbType,${env:WSL_META_USER},${env:WSL_META_PWD},"dbo.",$metaArch){%- br %}
    $root     = $repo.objectsByName{%- br %}
    $value    = $root[${env:WSL_EXP_NAME}].extendedPropertyValuesByName[$propertyName].GetValue(){%- br %}

    if([string]::IsNullOrEmpty($value)) { {%- br %}
        $value = $root[${env:WSL_EXP_TABLE}].loadInfo.sourceConnection.extendedPropertyValuesByName[$propertyName].GetValue(){%- br %}
    }{%- br %}
    if([string]::IsNullOrEmpty($value)) { {%- br %}
        $value = $root[${env:WSL_EXP_TABLE}].target.connection.extendedPropertyValuesByName[$propertyName].GetValue(){%- br %}
    }{%- br %}
    $repo.Dispose(){%- br %}
    return , $value{%- br %}
}{%- br %}
{%- br %}Function Export-Data { {%- br %}
    {%- br %}
    $logStream.WriteLine(""){%- br %}
    ${env:DEBUG}         = Get-ExtendedProperty -PropertyName "DEBUG_MODE"{%- br %}
    $BLOB_MODE           = Get-ExtendedProperty -PropertyName "BLOB_MODE"{%- br %}
    $TEMP_DATA_SOURCE    = Get-ExtendedProperty -PropertyName "TEMP_DATA_SOURCE"{%- br %}
    $BLOB_ACCOUNT        = Get-ExtendedProperty -PropertyName "BLOB_ACCOUNT"{%- br %}
    $BLOB_KEY            = Get-ExtendedProperty -PropertyName "BLOB_KEY"{%- br %}
    $BLOB_PROTOCOL       = Get-ExtendedProperty -PropertyName "BLOB_PROTOCOL"{%- br %}
    $BLOB_TEMP_CONTAINER = Get-ExtendedProperty -PropertyName "BLOB_TEMP_CONTAINER"{%- br %}
    $SEND_FILES_ZIPPED   = Get-ExtendedProperty -PropertyName "SEND_FILES_ZIPPED"{%- br %}
    $FILE_FORMAT         = Get-ExtendedProperty -PropertyName "FILE_FORMAT"{%- br %}
    $EXPORT_SINGLE_FILE  = Get-ExtendedProperty -PropertyName "EXPORT_SINGLE_FILE"{%- br %}
    {%- br %}
    if($BLOB_MODE -ne "TRUE") {
        $BLOB_MODE = "FALSE"
    }
    if([string]::IsNullOrEmpty($TEMP_DATA_SOURCE)) { {%- br %}
        $logStream.WriteLine("Temporary data source is not set"){%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("Temporary data source is not set"){%- br %}
        Print-Log{%- br %}
        Exit{%- br %}
    }{%- br %}
    if([string]::IsNullOrEmpty($BLOB_ACCOUNT)) { {%- br %}
        $logStream.WriteLine("Azure blob storage account is not set"){%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("Azure block storage account is not set"){%- br %}
        Print-Log{%- br %}
        Exit{%- br %}
    }{%- br %}
    if([string]::IsNullOrEmpty($BLOB_KEY)) { {%- br %}
        $logStream.WriteLine("Azure blob storage access key is not set"){%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("Azure blob storage access key is not set"){%- br %}
        Print-Log{%- br %}
        Exit{%- br %}
    }{%- br %}
    if([string]::IsNullOrEmpty($BLOB_PROTOCOL)) { {%- br %}
        $BLOB_PROTOCOL = "https"{%- br %}
        if(${env:DEBUG} -eq "TRUE") { {%- br %}
            $logStream.WriteLine("Blob protocol not set. Defaulting to '$BLOB_PROTOCOL'"){%- br %}
        }{%- br %}
    }{%- br %}
    if([string]::IsNullOrEmpty($BLOB_TEMP_CONTAINER)) { {%- br %}
        $logStream.WriteLine("Azure blob storage container is not set"){%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("Azure blob storage container is not set"){%- br %}
        Print-Log{%- br %}
        Exit{%- br %}
    }{%- br %}
    {%- br %}
    $dOdbcConn = New-Object System.Data.Odbc.OdbcConnection{% br %}
    $dOdbcConn.ConnectionString = "DSN=${env:WSL_SRC_DSN}"{% br %}
    {% br %}
    if( ! [string]::IsNullOrEmpty(${env:WSL_SRC_USER})) { {%- br %}
        $dOdbcConn.ConnectionString += ";UID=${env:WSL_SRC_USER}"{%- br %}
    }{%- br %}
    {%- br %}
    if( ! [string]::IsNullOrEmpty(${env:WSL_SRC_PWD})) { {%- br %}
        $dOdbcConn.ConnectionString += ";PWD=${env:WSL_SRC_PWD}"{%- br %}
    }{%- br %}
    {%- br %}
    $dOdbcConn.Open(){%- br %}
    {%- br %}
    if($EXPORT_SINGLE_FILE -eq "true") { {%- br %}
        $sourceRowCountSQL = "SELECT COUNT(*) FROM ${env:WSL_EXP_SCHEMA}.${env:WSL_EXP_TABLE}"{%- br %}
        try { {%- br %}
            $sourceRowCount = (New-Object System.Data.Odbc.OdbcCommand($sourceRowCountSQL,$dOdbcConn)).ExecuteScalar(){%- br %}
            $sourceRowCount = $sourceRowCount * 2
        }{%- br %}
        catch { {%- br %}
            $logStream.WriteLine($_.Exception.Message){%- br %}
            [Console]::WriteLine("-2"){%- br %}
            [Console]::WriteLine("Failed to fetch row count for single file export"){%- br %}
            Print-Log{%- br %}
            exit{%- br %}
        }{%- br %}
        $exportSelect = "SELECT TOP $sourceRowCount"
    }{%- br %}
    else {
        $exportSelect = "SELECT"
    }
    $extTableDropIfExists = @"
    IF EXISTS (SELECT *
               FROM   sys.external_tables
               WHERE  name      = 'extmp_${env:WSL_EXP_NAME}'
               AND    schema_id = (SELECT schema_id FROM sys.schemas WHERE name = '${env:WSL_EXP_SCHEMA}'))
    DROP EXTERNAL TABLE ${env:WSL_EXP_SCHEMA}.extmp_${env:WSL_EXP_NAME};
"@
    {%- br %}
    if(${env:DEBUG} -eq "TRUE") { {%- br %}
        $logStream.WriteLine("======= DROP EXTERNAL TABLE IF EXISTS ======="){%- br %}
        $logStream.WriteLine($extTableDropIfExists){%- br %}
        $logStream.WriteLine(""){%- br %}
    }{%- br %}
    try { {%- br %}
        $null = (New-Object System.Data.Odbc.OdbcCommand($extTableDropIfExists,$dOdbcConn)).ExecuteNonQuery(){%- br %}
    }{%- br %}
    catch { {%- br %}
        $logStream.WriteLine($_.Exception.Message){%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("Failed to drop existing external table"){%- br %}
        Print-Log{%- br %}
        exit{%- br %}
    }{%- br %}
    {%- br %}
    $fileNameInBlob    = '{{ table.exportInfo.file.name }}'
    $fileNameInBlob    = Replace-WslTags($fileNameInBlob)
    $extTableCreateSQL = @"
    CREATE EXTERNAL TABLE ${env:WSL_EXP_SCHEMA}.extmp_${env:WSL_EXP_NAME}
    WITH (LOCATION    = '$fileNameInBlob',
          DATA_SOURCE = $TEMP_DATA_SOURCE,
          FILE_FORMAT = $FILE_FORMAT
      {%- from table.exportInfo.options | lines as optLine %}
        {%- if loop.first %},{% br %}      {% endif -%}
        {{- optLine }}{% br %}
      {%- endfrom %}{% br %}
    )
    AS
    $exportSelect{% br %}
    {% from table.columns as column where (column.sourceColumn is defined) %}
      {%- if not loop.first %}    , {% else %}  {% endif %}
      {%- if column.sourceColumn is defined %}
        {{- column.sourceColumn.name }} {%- if (table.exportInfo.headerRow.name == 'Business names') and (column.sourceColumn is defined) %} AS "{{ column.displayName }}" {% br %} {%- endif %}
      {%- endif %}
    {%- endfrom %}
    FROM ${env:WSL_EXP_SCHEMA}.${env:WSL_EXP_TABLE} ${env:WSL_EXP_TABLE}{%- br %}
    {%- from table.exportInfo.whereClause | lines as whereLine %}
    {{ whereLine }}{% br %}
    {%- endfrom %}
"@
    {%- br %}
    if(${env:DEBUG} -eq "TRUE") { {%- br %}
        $logStream.WriteLine("======= CREATE EXTERNAL TABLE ======="){%- br %}
    }{%- br %}
    $logStream.WriteLine($extTableCreateSQL){%- br %}
    $logStream.WriteLine(""){%- br %}
    {%- br %}
    try { {%- br %}
        $rowcount = (New-Object System.Data.Odbc.OdbcCommand($extTableCreateSQL,$dOdbcConn)).ExecuteScalar(){%- br %}
    }{%- br %}
    catch { {%- br %}
        $logStream.WriteLine($_.Exception.Message){%- br %}
        [Console]::WriteLine("-2"){%- br %}
        [Console]::WriteLine("Failed to create external table for temporary BLOB file"){%- br %}
        Print-Log{%- br %}
        exit{%- br %}
    }{%- br %}
    if($BLOB_MODE -ne "TRUE") {
        try { {% br %}
            Import-Module Az.Storage
        }{% br %}
        catch { {% br %}
            $logStream.WriteLine($_.Exception.Message){% br %}
            $logStream.WriteLine("Az.Storage module is not installed. Install it using 'Install-Module Az.Storage'"){% br %}
            [Console]::WriteLine("-3"){% br %}
            [Console]::WriteLine("Failed to load required module"){% br %}
            Print-Log{% br %}
            exit{% br %}
        }{% br %}
        $blobContext = New-AzStorageContext -StorageAccountName $BLOB_ACCOUNT -StorageAccountKey $BLOB_KEY
        $blobs       = Get-AzStorageBlob -Blob "$fileNameInBlob/*" -Container $BLOB_TEMP_CONTAINER -Context $blobContext
        foreach($blob in $blobs) { {%- br %}
            if($blob.Length -ne 0){ {%- br %}
                $localFilePath = Join-Path -Path '{{ table.exportInfo.file.path }}' -ChildPath "{{table.exportInfo.file.name}}" {%- br %}
                $null          = Get-AzStorageBlobContent -Blob $blob.Name -Container $BLOB_TEMP_CONTAINER -Destination $localFilePath -Context $blobContext -Force {%- br %}
            }{%- br %}
        }{%- br %}
    }{%- br %}
    {% br %}
    # Clean Blob And Drop External Table
    $cleanupSQL = "DROP EXTERNAL TABLE ${env:WSL_EXP_SCHEMA}.extmp_${env:WSL_EXP_NAME};"{%- br %}
    $blobs       = Get-AzStorageBlob -Blob "$fileNameInBlob/*" -Container $BLOB_TEMP_CONTAINER -Context $blobContext | Remove-AzStorageBlob
    $blob       = Get-AzStorageBlob -Blob "$fileNameInBlob" -Container $BLOB_TEMP_CONTAINER -Context $blobContext | Remove-AzStorageBlob
    {%- br %}
    if($env:DEBUG -eq "TRUE") { {%- br %}
        $logStream.WriteLine("======= CLEANUP ======="){%- br %}
        $logStream.WriteLine($cleanupSQL){%- br %}
        $logStream.WriteLine(""){%- br %}
    }{%- br %}
    {%- br %}
    try { {%- br %}
        $deleteTable = (New-Object System.Data.Odbc.OdbcCommand($cleanupSQL,$dOdbcConn)).ExecuteNonQuery(){%- br %}
    }{%- br %}
    catch { {%- br %}
        $logStream.WriteLine($_.Exception.Message){%- br %}
        $logStream.WriteLine("Failed to drop external table and/or file format"){%- br %}
        [Console]::WriteLine("-1"){%- br %}
        [Console]::WriteLine("Export Completed with warnings."){%- br %}
        Print-Log{%- br %}
        exit{%- br %}
    }{%- br %}
    {%- br %}
    $logStream.WriteLine("Export complete."){%- br %}
    [Console]::WriteLine("1"){%- br %}
    [Console]::WriteLine("Export Complete."){%- br %}
}{%- br %}
try { {%- br %}
    $fileAud             = Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "wsl.${env:WSL_EXP_NAME}.${env:WSL_SEQUENCE}.txt"{%- br %}
    $fileDat             = Join-Path -Path ${env:WSL_WORKDIR} -ChildPath "wsl.${env:WSL_EXP_NAME}.${env:WSL_SEQUENCE}.dat"{%- br %}
    $logStream           = New-Object IO.StreamWriter($FileAud,$false){%- br %}
    $logStream.AutoFlush = $true{%- br %}
    {%- br %}
    Add-Type -Path $(Join-Path -Path ${env:WSL_BINDIR} -ChildPath "WslMetadataServiceClient.dll"){%- br %}
    $metaDbType          = [WslMetadataServiceClient.MetaDatabaseType]::SqlServer{%- br %}
    {%- br %}
    Export-Data{%- br %}
    {%  if (table.exportInfo.compressAfterExport  == true) %}{%- br %}
	$srcFile = Join-Path -Path '{{ table.exportInfo.file.path }}' -ChildPath '{{table.exportInfo.file.name}}' {%- br %}
	Archive-Files -srcFile $srcFile
	{%- endif %}{%- br %}
}{%- br %}
catch { {%- br %}
    $logStream.WriteLine("Unhandled Exception"){%- br %}
    $logStream.WriteLine($_.InvocationInfo.PositionMessage){%- br %}
    $logStream.WriteLine($_.Exception.Message){%- br %}
    [Console]::WriteLine("-2"){%- br %}
    [Console]::WriteLine("Export Failed"){%- br %}
}{%- br %}
finally { {%- br %}
    Print-Log{%- br %}
    exit{%- br %}
}{%- br %}
